function [Equivalence] = GeneratorsEquivalence(G1,G2)
% Check if generators set  G1 & G2 are gauge equivalent (up to a row transformation)
% Both tableaus and signvectors are compared. 

Equivalence.Overall = false;
Equivalence.Tableau = false;
Equivalence.SignVector = false;

n = size(G1.Tableau,1);
if size(G1.Tableau) ~= size(G2.Tableau)
    warning('Input generator sets have different size of tableau!');
end
P = [zeros(n),eye(n);eye(n),zeros(n)];
if all(mod(G1.Tableau * P * (G2.Tableau'),2) == zeros(n),'all')
    Equivalence.Tableau = true;
    A = logical(G1.Tableau');
    B = logical(G2.Tableau');
    M = [A,B]; 
    % If A*X == B, then we will find this X from M = [A,A*X],
    % That is, find echelon form Mrref == [I,I*X] by row reduction;
    [Mrref,~,~,~] = rrefgf(M,2);
    X = logical(Mrref(1:n,n+(1:n)));
    if all(mod(A*X,2) == mod(B,2),'all')
        R = X.';
    else
        fprintf(1,'AX ~= B (mod 2) \n')
    end
    G1_g = GaugeTransformation(G1,R);
    if  all(G1_g.SignVector == G2.SignVector, 'all')
        Equivalence.SignVector = true;
    else
        warning('Sign vectors are NOT identical!');
%         mod(G1_g.SignVector,2)
%         mod(G2.SignVector,2)
    end
end
if Equivalence.SignVector && Equivalence.Tableau
    Equivalence.Overall = true;
end
end


function [Arref,basis,Arank,Ainv] = rrefgf(A,field)
% rrefgf: Reduced row echelon form, in the multiplicative group of integers modulo field.
% usage: [Arref,basis,Arank,Ainv] = rrefgf(A,field)
%
% arguments: (input)
%   A - A matrix of all integer elements
%
%   field - scalar integer variable, a PRIME number, 2 <= field <= 2^31
%
% arguments: (output)
%   Arref - The reduced row echelon form of A in the group of integers
%       defined by field. IF A is full rank, then Arref will be the
%       identity matrix.
%
%       It is required that field be a prime integer >1, not exceeding
%       2^31.
%
%       rrefgf operates in int64 arithmetic, although Arref will have
%       the same class as A.
%
%   basis - vector of integers, such that
%       r = length(basis) is the rank of A in the indicated field,
%       x(basis) are the bound variables in a linear system, Ax = b,
%       A(:,basis) is a basis for the range of A,
%       Arref(1:r,basis) is the r-by-r identity matrix.
%
%   Arank - scalar integer, indicating the true rank of A in the chosen field.
%       Since all computations are done in integer arithmetic, this is the
%       exact rank.
%
%   Ainv - When A is a square matrix of full rank in the given field,
%       then Ainv will exist and will be returned, such that
%
%         mod(A*Ainv,field) == eye(size(A))
%
%       IF a is non-square, or not of full rank, then Ainv will be empty.
%
% Example 1:
% A = magic(3)
% A =
%      8     1     6
%      3     5     7
%      4     9     2
%      
% In the mutiplicative group induced by modulus of 11, A is full rank.
% [Ar,jb] = rrefgf(A,11)
% Ar =
%      1     0     0
%      0     1     0
%      0     0     1
% jb =
%      1     2     3
%
% The inverse of A in that group is easily obtained by appending an
% identity to A.
% Ar = rrefgf([A,eye(size(A))],11)
% Ar =
%      1     0     0     8    10     7
%      0     1     0     0     1     2
%      0     0     1     6     3     5
%      
% mod(A*Ar(:,4:6),11)
% ans =
%      1     0     0
%      0     1     0
%      0     0     1
%
%   Class support for input A:
%      float: double, single, or any integer class
%
%   See also RANK, ORTH, NULL, QR, SVD.

[m,n] = size(A);

if (field <= 1) || (rem(field,1) ~= 0) || (field > 2^31) || ~isprime(field)
  error('field must be a prime positive integer greater than 1, not exceeding 2^31.')
end

% do we try to compute the inverse of A?
invflag = false;
Ainv = [];
if (nargout > 3) && (size(A,1) == size(A,2))
  invflag = true;
  Ainv = eye(size(A),'int64');
end

% convert to int64, but remember how A started.
% int64 will allow us to do all arithmetic on numbers in a
% field generated by a modulus no larger than 2^31, since the product of
% two such integers will not exceed the limits of int64.
Aclass = class(A);
A = int64(A);
field = int64(field);
% reduce A modulo field, just in case
A = mod(A,field);

% pivoting performed as needed
basis = [];
for i = 1:min(m,n)
   % locate a non-zero pivot element
   % We need an element in the remaining matrix that has a gcd of 1 with field.
   % since field is assured to be prime, any non-zero will suffice.
   jrem = setdiff(1:n,basis);
   % the find will locate the first pivot element in the first non-zero remaining
   % column, if that is possible.
   [rpiv,cpiv] = find(A(i:m,jrem),1,'first');
   rpiv = rpiv + i - 1;
   cpiv = jrem(cpiv);
   if isempty(cpiv)
     % the remaining elements are all zero in this field, so we are done.
     % an inverse will not exist if a pivot was not found.
     Ainv = [];
     Arank = i-1;
     Arref = cast(A,Aclass); 
     return
   end
   
   % a non-zero element was found to act as a pivot
   p = A(rpiv,cpiv);
   
   % Remember column index to form the basis
   basis(end + 1) = cpiv;
   
   % Swap rows?
   if rpiv ~= i
     A([i rpiv],jrem) = A([rpiv i],jrem);
     if invflag
       % swap rows
       Ainv([i rpiv],:) = Ainv([rpiv i],:);
     end
   end
   
   % Divide the pivot row by the pivot element. This turns into a 
   % multiply by the modular inverse of the pivot.
   pivinv = minv(p,field);
   A(i,jrem) = mod(A(i,jrem)*pivinv,field);
   if invflag
     Ainv(i,:) = mod(Ainv(i,:)*pivinv,field);
   end
   
   % Subtract multiples of the pivot row from all the other rows.
   irem = [1:(i-1),(i+1):m];
   for k = irem
     Acpiv = A(k,cpiv);
     A(k,jrem) = mod(A(k,jrem) - Acpiv*A(i,jrem),field);
     if invflag
       Ainv(k,:) = mod(Ainv(k,:) - Acpiv*Ainv(i,:),field);
     end
   end
   
end

% If we drop down to here, then A was full rank, since there were no zero
% pivots
Arank = min(m,n);

% done. We need to return A to its original class.
Arref = cast(A,Aclass);
if invflag
  Ainv = cast(Ainv,Aclass);
end
end

function xinv = minv(x,field)
  % returns the modular inverse of x in the defined field.
  [G,C,~] = gcd(x,field);
  if G ~= 1
    xinv = [];
  else
    % the other outputs [G,C,D]=gcd(x,field) are such that 
    % x*C + field*D = G
    % we don't care about D (the third output), so C gives us the modular
    % inverse of x. Make sure it is reduced though.
    xinv = mod(C,field);
  end
end
  
  